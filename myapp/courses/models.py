from django.db import modelsfrom django.utils.translation import ugettext_lazy as _from django.utils import timezonefrom django.contrib.postgres.fields import ArrayField# from rest_framework.response import Responseimport sysimport StringIOimport timeitimport numpy as np# import astclass Course(models.Model):    # Unique-together fields    course_batch = models.CharField(        _('course batch'),        max_length=20,        blank=True,        null=False,        help_text=_('e.g. FY15T3 (for Year 2015 Term 3)')    )    course_code = models.CharField(        _('course code'),        max_length=20,        blank=True,        null=False,        help_text=_('e.g. CS101')    )    school = models.CharField(        max_length=100,        blank=True,        null=True,        help_text=_('e.g. SUTD')    )    department = models.CharField(        max_length=100,        blank=True,        null=True,        help_text=_('e.g. ISTD')    )    # Other fields    title = models.CharField(        max_length=50,        blank=True,        null=True,        help_text=_('e.g. Digital World')    )    description = models.TextField(        max_length=255,        blank=True,        null=True,        help_text=_('e.g. An introduction course to programming using Python')    )    programming_language = models.CharField(        _('programming language'),        max_length=55,        blank=False,        null=False,        help_text=_('e.g. Python')    )  # e.g. Python    start_date = models.DateField(        _('start date'),        null=False,        blank=False    )    end_date = models.DateField(        _('end date'),        null=False,        blank=False    )    date_created = models.DateTimeField(        _('date created'),        default=timezone.now    )    # Foreign keys    participants = models.ManyToManyField(        'authnz.ProqodUser',        related_name='courses'    )    class Meta:        verbose_name = _('course')        verbose_name_plural = _('courses')        ordering = ['date_created']        unique_together = (            "course_batch", "course_code", "school", "department")    def get_absolute_path(self):        return "/courses/%i/" % self.pk    def __str__(self):        return "%s_%s_%s_%s" % (            self.school, self.department, self.course_code, self.title        )class Assessment(models.Model):    """    A short test of knowledge to particular topics that    can be a form of coding problem, MCQ or Blanks    """    LAB, QUIZ, PROJECT, EXAM, COHORT, HOMEWORK, OPTIONAL = range(7)    TYPE = (        (LAB, 'lab'),        (QUIZ, 'quiz'),        (PROJECT, 'project'),        (EXAM, 'exam'),        (COHORT, 'cohort session'),        (HOMEWORK, 'homework'),        (OPTIONAL, 'optional exercise'),    )    # fields    type = models.CharField(        _("type"),        max_length=5,        default=LAB,        choices=TYPE,        null=False,        blank=False    )    label = models.CharField(        _("label"),        max_length=20,        null=False,        blank=False,    )    # If null, available all the time    start_datetime = models.DateTimeField(        _('start date time'),        null=True,        blank=True    )    end_datetime = models.DateTimeField(        _('end date time'),        null=True,        blank=True    )    # OneToMany: A course can have many quizes    course = models.ForeignKey('Course', related_name='quizes')    class Meta:        verbose_name = _('assessment')        verbose_name_plural = _('assessments')        ordering = ['type', 'label']        # unique_together = ("type", "label")    def __str__(self):        return "%s" % self.id        # return "course %s assessment %s type %s" % (        #     self.course.course_code, self.label, self.type        # )class Question(models.Model):    """    Question include 3 types (and others):    Programming, MCQ, Blanks.    """    PROGRAMMING, MCQ, BLANKS, CHECKOFF, OTHERS = range(5)    TYPE = (        (PROGRAMMING, "programming"),        (MCQ, "mcq"),        (BLANKS, "blank"),        (CHECKOFF, "check off"),        (OTHERS, "others")    )    assessment = models.ForeignKey(        'Assessment',        null=True,        blank=True,        # related_name="%(class)s",    )    number = models.PositiveSmallIntegerField(        _("question no"),        null=False,        blank=False,        help_text="a question number unique together with the assessment"    )    type = models.PositiveSmallIntegerField(        _("question type"),        default=PROGRAMMING,        choices=TYPE    )    description = models.TextField(        _("description"),        null=True,        blank=True,    )    solution = models.TextField(        _("solution"),        null=True,        blank=True,    )    class Meta:        verbose_name = "%(class)s"        ordering = ['assessment', 'number']        unique_together = ("assessment", "number")        abstract = True    def __str__(self):        return "%s" % self.id# def question_directory_path(instance, filename):# file will be uploaded to MEDIA_ROOT/assessment_<label>/question_<num>/<filename>#     return 'assessment_{0}/question_{1}/{2}'.format(#         instance.assessment.label,#         instance.question.question_num,#         filename#     )class ProgrammingQuestion(Question):    code_signature = models.CharField(        _("code_signature"),        max_length=50,        null=True,        blank=True    )    default_code = models.TextField(        _("default_code"),        null=True,        blank=True,    )    # files = models.ArrayField(    #     models.FileField(    #         upload_to='a'    #     )    #     blank=True,    #     null=True,    #     help_text=_("list of files")    # )    # class Meta:    #     verbose_name = _('programming_question')    #     verbose_name_plural = _('programming_questions')class BlankQuestion(Question):    pass    # class Meta:    #     verbose_name = _('blank_question')    #     verbose_name_plural = _('blank_questions')class Mcq(Question):    pass    # class Meta:    #     verbose_name = _('multiple_choice_question')    #     verbose_name_plural = _('multiple_choice_questions')class CheckoffQuestion(Question):    pass    # class Meta:    #     verbose_name = _('checkoff_question')    #     verbose_name_plural = _('checkoff_questions')    # score = models.PositiveSmallIntegerField(    #     _("code_signature"),    #     default=0,    #     null=True,    #     blank=True,    # )    # checked = models.BooleanField(    #     _("checked"),    #     default=False,    #     null=True,    #     blank=True,    #     )class MultipleChoice(models.Model):    """    Custom for Multiple Choice Questions.    """    content = models.CharField(        _("content"),        max_length=200,        null=False,        blank=True    )    question = models.ForeignKey(        "Mcq",        related_name="choices"    )    is_correct = models.BooleanField(        _("is correct"),        default=False    )    class Meta:        verbose_name = _('multiple_choice')        verbose_name_plural = _('multiple_choices')        ordering = ['question']        unique_together = ("question", 'content')class BlankQuestionContent(models.Model):    """    Custom for Blank type of questions.    A blank is expected between each two parts.    seq is positive integer unique together with question.    """    part_seq = models.PositiveSmallIntegerField(        _("sequence"),        null=False,        blank=False,        help_text=_("sequence unique together with question")    )    content = models.CharField(        _("content"),        max_length=200,        null=False,        blank=True    )    question = models.ForeignKey(        "BlankQuestion",        null=False,        blank=False,        related_name="blank_parts"    )    class Meta:        verbose_name = _('blank_question_part')        verbose_name_plural = _('blank_question_parts')        ordering = ['question', 'part_seq']        unique_together = (            'part_seq', 'question'        )    def __str__(self):        return "%s" % self.idclass BlankSolution(models.Model):    """    Contains a solution set for a blank question    """    seq = models.PositiveSmallIntegerField(        _("sequence"),        null=False,        blank=False,        help_text=_("sequence unique together with question")    )    content = models.CharField(        _("content"),        max_length=200,        null=False,        blank=True    )    question = models.ForeignKey(        "BlankQuestion",        related_name="solution_set"    )    def __str__(self):        return "%s" % self.idclass TestCase(models.Model):    """    Test case for question's solution checking.    Each test case will have an array of inputs and an array of expected outputs.    For programming questions, the array of expected_output will likely be one entry.    ArrayField expects regular shape.    """    PUBLIC, PRIVATE = range(2)    VISIBILITY = (        (PUBLIC, 'Public'),        (PRIVATE, 'Private'),    )    MATCHING, NUMBER, KEYWORDS = range(3)    TYPES = (        (MATCHING, "matching"),        (NUMBER, "number"),        (KEYWORDS, "keywords"),    )    visibility = models.IntegerField(        default=PUBLIC,        choices=VISIBILITY    )    type = models.IntegerField(        _("type"),        default=MATCHING,        choices=TYPES,        help_text=_("type of test cases")    )    test_content = models.TextField(        _("test_content"),        max_length=100000,        null=False,        blank=False,        default="",        help_text=("purpose of the test case")    )    def __str__(self):        return "%s" % self.id    class Meta:        verbose_name = _('test_case')        verbose_name_plural = _('test_cases')        abstract = Trueclass UnitTest(TestCase):    question = models.ForeignKey(        'ProgrammingQuestion',        related_name="unittests",    )    inputs = ArrayField(        models.CharField(            _("input_values"),            max_length=255,            default="",            null=True,            blank=True        ),        blank=True,        null=True,        help_text=_("each input in its raw form")    )    expected_output = models.TextField(        _("expected_output"),        max_length=1024,        default="",        blank=True,        null=True,        help_text=_("expected output in string format")    )    def get_test(self):        signature = self.question.code_signature        inputs = self.inputs        if inputs:            # inputs = ast.literal_eval(inputs)            inputs = ["'%s'" % x for x in inputs]        str_input = ",".join(inputs)        return "%s(%s)" % (signature, str_input)    def run(self, code):        codeOut = StringIO.StringIO()        codeErr = StringIO.StringIO()        sys.stdout = codeOut        sys.stderr = codeErr        output = self.expected_output        code += """\nprint %s        """ % self.get_test()        try:            exec code        except:            return {                "pass": False,                "error": "fail to execute code"            }        sys.stdout = sys.__stdout__        sys.stderr = sys.__stderr__        result = codeOut.getvalue().strip()        if result:            return {                "pass": (result == output),                "output": result,                "time": self.time(code)            }        return {            "pass": False,            "error": codeErr.getvalue()        }    def time(self, code, times=3, lang="Python"):        """        Measure the execution time for a snippet in microsecond.        Taking average of 10 execution times by default.        """        code += """\nprint %s        """ % self.get_test()        try:            record = np.mean(timeit.repeat(code, repeat=times))            return record        except:            # Return -1 if there's an error            return -1